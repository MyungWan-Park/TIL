## Dynamic_Programming

* 이것이 코딩테스트다
  * 그리디
  * 구현
  * DFS and BFS
  * 정렬
    * 선택정렬
    * 삽입정렬
    * 퀵정렬
    * 계수정렬
  * 이진탐색
  * **Dynamic_Programming**
  * 최단거리
  * 그래프 알고리즘

>	## When to use?

먼가 규칙이 없으면 못풀것 같은 문제 & 부분 값을 구한것이 계속 같아서 연산 횟수를 줄이고 싶을때

>	## How to use?
>   > 1. 보기의 값으로 예를 들어본다.
    > 2. 앞에서 부터 차례대로 살펴보면서 규칙을 찾는다.
    > 3. 앞에 1000개의 수열이 이미 있다고 생각하고, 1001번째, 1002번째 등 과의 관계를 살펴본다.

**Bottom-up**(재귀를 이용하고, 연산 값을 배열에 저장하여 중복 연산을 줄인다.- Memoization)과 
**Top-down**(반복문을 이용하고, 연산 값을 배열에 저장하여 차곡 차곡 쌓는다. - DP table)
이 둘 중 Top Down을 더 선호한다. 재귀함수를 돌릴 수 있는 깊이가 한정되어 있기 때문이다. 